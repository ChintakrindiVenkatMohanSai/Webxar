<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>True AR Viewer</title>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/webxr/ARButton.js"></script>

<style>
body{
margin:0;
overflow:hidden;
font-family:sans-serif;
background:black;
}

#info{
position:absolute;
top:20px;
width:100%;
text-align:center;
color:white;
z-index:10;
font-weight:bold;
}
</style>
</head>

<body>

<div id="info">
Tap "START AR" → Scan floor/wall → Tap screen to place image
</div>

<script>

let camera, scene, renderer;
let controller;
let reticle;
let hitTestSource = null;
let hitTestSourceRequested = false;

init();

function init(){

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.01,20);

renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.xr.enabled = true;

document.body.appendChild(renderer.domElement);
document.body.appendChild(ARButton.createButton(renderer,{requiredFeatures:['hit-test']}));

/* LIGHT */
scene.add(new THREE.HemisphereLight(0xffffff,0xbbbbff,1));

/* RETICLE (placement indicator) */
const ringGeo = new THREE.RingGeometry(0.08,0.1,32);
ringGeo.rotateX(-Math.PI/2);

reticle = new THREE.Mesh(
ringGeo,
new THREE.MeshBasicMaterial({color:0x00ffff})
);
reticle.matrixAutoUpdate=false;
reticle.visible=false;
scene.add(reticle);


/* IMAGE TEXTURE */
const texture = new THREE.TextureLoader().load(
"/uploads/{{ filename }}"
);

const plane = new THREE.Mesh(
new THREE.PlaneGeometry(0.6,0.6),
new THREE.MeshBasicMaterial({map:texture,transparent:true})
);

controller = renderer.xr.getController(0);
controller.addEventListener("select",()=>{
if(reticle.visible){
const clone = plane.clone();
clone.position.setFromMatrixPosition(reticle.matrix);
clone.quaternion.setFromRotationMatrix(reticle.matrix);
scene.add(clone);
}
});

scene.add(controller);

renderer.setAnimationLoop(render);
}


function render(timestamp,frame){

if(frame){

const refSpace = renderer.xr.getReferenceSpace();
const session = renderer.xr.getSession();

if(!hitTestSourceRequested){

session.requestReferenceSpace("viewer").then(space=>{
session.requestHitTestSource({space}).then(src=>{
hitTestSource = src;
});
});

session.addEventListener("end",()=>{
hitTestSourceRequested=false;
hitTestSource=null;
});

hitTestSourceRequested=true;
}

if(hitTestSource){

const hitTestResults = frame.getHitTestResults(hitTestSource);

if(hitTestResults.length){

const hit = hitTestResults[0];
const pose = hit.getPose(refSpace);

reticle.visible=true;
reticle.matrix.fromArray(pose.transform.matrix);

}else{

reticle.visible=false;
}
}
}

renderer.render(scene,camera);
}

</script>

</body>
</html>